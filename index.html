<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Kreator Bombki - Galant Art Design</title>
    <style>
        :root { --panel-bg: #1e1e1e; --item-bg: #2d2d2d; --text: #e0e0e0; --accent: #3498db; }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; background: #000; color: var(--text); overflow: hidden; }
        #canvas-container { flex: 1; position: relative; }
        #ui-panel { width: 380px; background: var(--panel-bg); padding: 20px; overflow-y: auto; border-left: 1px solid #333; }
        .section { background: var(--item-bg); border-radius: 10px; padding: 15px; margin-bottom: 20px; border: 1px solid #444; }
        h3 { font-size: 13px; margin: 0 0 12px 0; text-transform: uppercase; color: #888; }
        label { display: block; font-size: 11px; margin: 10px 0 5px; color: #aaa; }
        .control-row { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
        .input-group { display: flex; gap: 5px; width: 100%; margin-bottom: 10px; }
        input[type="text"] { flex: 1; background: #111; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; font-size: 12px; }
        input[type="color"] { width: 50px; height: 38px; border: none; background: none; cursor: pointer; }
        button { background: #444; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; flex: 1; min-width: 60px; }
        button:hover { background: #555; }
        select, input[type="range"] { width: 100%; background: #111; color: white; border: 1px solid #444; padding: 8px; border-radius: 4px; }
        #loader { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
        .spinner { border: 4px solid #333; border-top: 4px solid var(--accent); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loader"><div class="spinner"></div><p>Wczytywanie bombki...</p></div>
<div id="canvas-container"></div>

<div id="ui-panel">
    <div class="section">
        <h3>1. Oświetlenie i Tło</h3>
        <select id="hdri-select" onchange="updateHDRI(this.value)">
            <option value="textures/geislingen_an_der_steige_2k.hdr">Geislingen</option>
            <option value="textures/royal_esplanade_4k.hdr">Royal Esplanade</option>
            <option value="textures/spiaggia_di_mondello_4k.hdr">Spiaggia Mondello</option>
        </select>
        <label>Tryb tła:</label>
        <select id="bg-mode" onchange="toggleBackgroundMode(this.value)">
            <option value="hdri">Pokaż HDRI</option>
            <option value="color">Jednolity Kolor</option>
        </select>
        <input type="color" id="bg-color-picker" value="#1a1a1a" oninput="updateBgColor(this.value)">
        <label>Obrót światła (HDRI):</label>
        <input type="range" id="hdri-rot" min="0" max="6.28" step="0.01" value="0" oninput="rotateEnv(this.value)">
    </div>

    <div class="section">
        <h3>2. Bombka i Wstążka</h3>
        <label>Kolor Bombki:</label>
        <div class="input-group">
            <input type="color" id="cp-Sphere" value="#ffffff" oninput="updateColor('Sphere', this.value)">
            <input type="text" id="hex-Sphere" placeholder="#ffffff" onchange="updateColor('Sphere', this.value)">
        </div>
        <label>Kolor Wstążki i Zawieszki:</label>
        <div class="input-group">
            <input type="color" id="cp-Ribbon" value="#ffffff" oninput="updateColor('Ribbon', this.value); updateColor('Hang', this.value)">
            <input type="text" id="hex-Ribbon" placeholder="#ffffff" onchange="updateColor('Ribbon', this.value); updateColor('Hang', this.value)">
        </div>
    </div>

    <div class="section">
        <h3>3. Etykieta (Badge)</h3>
        <label>Wgraj Front (Badge_Front):</label>
        <input type="file" onchange="updateBadgeSide('Badge_Front', this)">
        
        <label>Wgraj Tył (Badge_Back):</label>
        <input type="file" onchange="updateBadgeSide('Badge_Back', this)">
        
        <label>Skala Etykiety:</label>
        <div class="control-row">
            <button onclick="setScale('Badge', 0.6)">0.6x</button>
            <button onclick="setScale('Badge', 1.0)">1.0x</button>
            <button onclick="setScale('Badge', 1.3)">1.3x</button>
        </div>
    </div>

    <div class="section">
        <h3>4. Logo</h3>
        <input type="file" accept="image/png" onchange="updateLogoTexture(this)">
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, model, pmremGenerator, currentHDRTexture;
    const texLoader = new THREE.TextureLoader();

    async function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(40, (window.innerWidth - 380) / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.5, 4);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - 380, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        pmremGenerator = new THREE.PMREMGenerator(renderer);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        updateHDRI(document.getElementById('hdri-select').value);

        new GLTFLoader().load('Bombka.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            document.getElementById('loader').style.display = 'none';
        });

        animate();
    }

    // --- LOGIKA HDRI ---
    window.updateHDRI = (path) => {
        new RGBELoader().load(path, (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            currentHDRTexture = texture;
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            if (document.getElementById('bg-mode').value === 'hdri') scene.background = envMap;
            rotateEnv(document.getElementById('hdri-rot').value);
        });
    };

    window.rotateEnv = (val) => {
        const rot = parseFloat(val);
        if (currentHDRTexture) {
            currentHDRTexture.offset.set(rot / (2 * Math.PI), 0);
            const envMap = pmremGenerator.fromEquirectangular(currentHDRTexture).texture;
            scene.environment = envMap;
            if (scene.background instanceof THREE.Texture) scene.background = envMap;
        }
    };

    window.toggleBackgroundMode = (mode) => {
        scene.background = (mode === 'color') ? new THREE.Color(document.getElementById('bg-color-picker').value) : scene.environment;
    };

    window.updateBgColor = (hex) => {
        document.getElementById('bg-mode').value = 'color';
        scene.background = new THREE.Color(hex);
    };

    // --- FUNKCJE MODELU ---
    window.updateColor = (name, hex) => {
        const color = new THREE.Color(hex);
        model.traverse(n => {
            if (n.isMesh && n.name.toLowerCase().includes(name.toLowerCase())) {
                n.material.color = color;
            }
        });
        if(document.getElementById('hex-' + name)) document.getElementById('hex-' + name).value = hex;
        if(document.getElementById('cp-' + name)) document.getElementById('cp-' + name).value = hex;
    };

    window.setScale = (name, s) => {
        model.traverse(n => { if (n.name.toLowerCase().includes(name.toLowerCase())) n.scale.set(s, s, s); });
    };

    // LOGIKA PROTOTYPU DLA BADGE
    window.updateBadgeSide = (matName, input) => {
        if (!input.files[0]) return;
        const url = URL.createObjectURL(input.files[0]);
        
        texLoader.load(url, (texture) => {
            texture.flipY = false;
            texture.colorSpace = THREE.SRGBColorSpace;

            model.traverse(node => {
                if (node.isMesh && node.name.toLowerCase().includes('badge')) {
                    const materials = Array.isArray(node.material) ? node.material : [node.material];
                    
                    materials.forEach(mat => {
                        // Szukamy materiału o nazwie Badge_Front lub Badge_Back
                        if (mat.name.includes(matName)) {
                            mat.color.set(0xffffff); // Czyścimy kolor bazowy
                            mat.map = texture;       // Base Color
                            mat.alphaMap = texture;  // Alpha
                            mat.transparent = true;
                            mat.alphaTest = 0.05;
                            mat.needsUpdate = true;
                        }
                    });
                }
            });
            URL.revokeObjectURL(url);
        });
    };

    window.updateLogoTexture = (input) => {
        if (!input.files[0]) return;
        const url = URL.createObjectURL(input.files[0]);
        texLoader.load(url, (tex) => {
            tex.flipY = false;
            tex.colorSpace = THREE.SRGBColorSpace;
            model.traverse(n => {
                if (n.isMesh && n.name.toLowerCase().includes('logo')) {
                    n.material.color.set(0xffffff);
                    n.material.map = tex;
                    n.material.alphaMap = tex;
                    n.material.transparent = true;
                    n.material.alphaTest = 0.05;
                    n.material.needsUpdate = true;
                }
            });
        });
    };

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>