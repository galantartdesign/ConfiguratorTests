<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Konfigurator Bombki - Final Debug</title>
    <style>
        body { margin: 0; background: #111; color: white; font-family: sans-serif; display: flex; }
        #canvas-container { flex: 1; height: 100vh; }
        #ui-panel { width: 350px; background: #222; padding: 20px; border-left: 1px solid #444; overflow-y: auto; }
        .section { background: #333; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        input, select { width: 100%; margin: 10px 0; padding: 8px; background: #111; color: white; border: 1px solid #555; }
        #status-log { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; font-size: 12px; color: #0f0; pointer-events: none; }
    </style>
</head>
<body>

<div id="status-log">Status: Inicjalizacja...</div>
<div id="canvas-container"></div>

<div id="ui-panel">
    <div class="section">
        <h3>1. Oświetlenie (HDRI)</h3>
        <select id="hdri-select" onchange="updateHDRI(this.value)">
            <option value="textures/geislingen_an_der_steige_2k.hdr">Geislingen (2k)</option>
            <option value="textures/royal_esplanade_4k.hdr">Royal Esplanade (4k)</option>
            <option value="textures/spiaggia_di_mondello_4k.hdr">Spiaggia Mondello (4k)</option>
        </select>
        <label>Obrót światła:</label>
        <input type="range" id="hdri-rot" min="0" max="6.28" step="0.01" value="0" oninput="applyRotation(this.value)">
    </div>

    <div class="section">
        <h3>2. Etykieta (Badge)</h3>
        <label>Front:</label>
        <input type="file" onchange="updateBadgeSpecific(0, this)">
        <label>Tył:</label>
        <input type="file" onchange="updateBadgeSpecific(1, this)">
    </div>

    <div class="section">
        <h3>3. Kolory</h3>
        <label>Bombka:</label>
        <input type="color" value="#ffffff" oninput="updateColor('Sphere', this.value)">
        <label>Wstążka:</label>
        <input type="color" value="#ffffff" oninput="updateColor('Ribbon', this.value)">
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, model, pmremGenerator;
    const log = (msg) => document.getElementById('status-log').innerText = "Status: " + msg;

    async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, (window.innerWidth - 350) / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.5, 4);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 350, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        pmremGenerator = new THREE.PMREMGenerator(renderer);
        controls = new OrbitControls(camera, renderer.domElement);

        updateHDRI(document.getElementById('hdri-select').value);

        new GLTFLoader().load('Bombka.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            log("Model załadowany.");
        });

        animate();
    }

    // NAPRAWA OBROTU HDRI - r160 wymaga modyfikacji environmentRotation
    window.applyRotation = (val) => {
        const r = parseFloat(val);
        scene.environmentRotation.set(0, r, 0);
        if (scene.background instanceof THREE.Texture) {
            scene.backgroundRotation.set(0, r, 0);
        }
    };

    window.updateHDRI = (path) => {
        new RGBELoader().load(path, (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = envMap;
            log("HDR aktywny.");
            applyRotation(document.getElementById('hdri-rot').value);
        }, undefined, (err) => log("BŁĄD HDR: " + path));
    };

    // NAPRAWA BADGE - Szukamy konkretnych materiałów po nazwach z Twojego Blendera
    window.updateBadgeSpecific = (index, input) => {
        if (!input.files[0]) return;
        const url = URL.createObjectURL(input.files[0]);
        new THREE.TextureLoader().load(url, (tex) => {
            tex.flipY = false;
            tex.colorSpace = THREE.SRGBColorSpace;
            
            // Celujemy w nazwy materiałów: Badge_Front i Badge_Back
            const targetName = (index === 0) ? "Badge_Front" : "Badge_Back";
            
            model.traverse(n => {
                if (n.isMesh && n.name.toLowerCase().includes('badge')) {
                    const mats = Array.isArray(n.material) ? n.material : [n.material];
                    mats.forEach(m => {
                        if (m.name.includes(targetName)) {
                            m.map = tex;
                            m.needsUpdate = true;
                            log("Zmieniono: " + targetName);
                        }
                    });
                }
            });
        });
    };

    window.updateColor = (name, hex) => {
        model.traverse(n => {
            if (n.isMesh && n.name.toLowerCase().includes(name.toLowerCase())) {
                n.material.color.set(hex);
            }
        });
    };

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>